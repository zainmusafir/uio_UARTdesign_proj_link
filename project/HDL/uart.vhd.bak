
library ieee;
use ieee.std_logic_1164.all;

entity uart is
    generic (
        GC_SYSTEM_CLK : integer := 50_000_000;
        GC_BAUD_RATE  : integer := 115_200
    );
	 
	 
  port(
    clk          : in std_logic;
    arst_n       : in std_logic;
    -- processor interface
    we           : in std_logic;
    re           : in std_logic;
    wdata        : in std_logic_vector (31 downto 0);
    rdata        : out std_logic_vector (31 downto 0);
    addr         : in std_logic_vector (1 downto 0);
    -- uart interface
    rx           : in std_logic;
    tx           : out std_logic;
    -- interrupt interface
    irq          : out std_logic
  );
end entity;



architecture mixed of uart is
    
	 
	 
	 
    signal mm_tx_data      : std_logic_vector(7 downto 0); 
    signal mm_rx_data      : std_logic_vector(7 downto 0); 
	 
    signal mm_tx_status    : std_logic_vector(7 downto 0) := "00000000";
   

    -- signals for the port components in rx_uart and tx_uart
    signal tx_busy         : std_logic;
    signal rx_busy         : std_logic;
    signal rx_err          : std_logic;
    signal rx_data         : std_logic_vector (7 downto 0);
  
    

component UART_rx
    port (
        clk : in std_logic;
        areset_n : in std_logic;
		  
		  
        rx_data : out std_logic_vector (7 downto 0);
        rx_err : out std_logic;
        rx_busy : out std_logic;
        rx : in std_logic --;
    
    );
    end component;

component UART_tx

    port(
        clk : in std_logic;
        tx_data_valid : in std_logic;
        areset_n : in std_logic;
		  
		  
        tx_data : in std_logic_vector (7 downto 0);
        tx_busy : out std_logic;
        tx_bit : out std_logic
    
	 
    );
    end component;

begin
  p_reg: process(arst_n, clk)
    begin
      if arst_n = '0' then
        mm_tx_data <= (others => '0');
        mm_rx_data <= (others => '0');
        mm_tx_status <= (others => '0');
        -- data_reg4 <= (others => '0');
      elsif rising_edge(clk) then
        if tx_busy='1' and mm_tx_busy='0' then
            mm_tx_data_valid <='0';
        end if;
        -- create tx and rx irq flags
        -- this one creates a tx_irq pulse on a falling edge of tx_busy
        if mm_tx_busy='1' and tx_busy='0' then
            mm_tx_irq <= '1';
        end if;
        -- this one creates a rx_irq pulse on a falling edge of rx_busy
        if mm_rx_busy='1' and rx_busy='0' then
            mm_rx_irq <='1';
            mm_rx_data <= rx_data;
        end if;
        -- Write to registers
        if we = '1' then 
          case addr is
            when "00" =>  -- We write the data from the CPU bus to the register
              mm_tx_data <= wdata (7 downto 0);
              mm_tx_data_valid <='1';
            when "10" =>  -- The CPU wants to reset the interrupt condition
              mm_rx_irq <= '0';
              mm_tx_irq <= '0';
            when others =>
              null;
          end case;
        end if;
        -- Read from registers
        if re = '1' then 
          case addr is
            when "01" =>
              rdata <= x"000000" & mm_rx_data; -- CPU wants to read rdata, so we convert rx_data to 32 bits
            when "10" =>
              rdata <= x"000000" & mm_tx_status;
            when others =>
              rdata <= x"00000000";  
          end case;
        end if;
      -- Update the rest of the status registers
      mm_tx_busy <= tx_busy;
      mm_rx_busy <= rx_busy;
      mm_rx_err <= rx_err;
    end if; -- end of the elsif 
  end process;

-- Here is the space for the component calls and combinatorial logic
-- We need to generate a single interrupt request for the CPU to get its
-- attention if either rx or tx completes
irq <= mm_tx_irq or mm_rx_irq;

TX1: tx_uart port map(clk => clk,
tx_data_valid => mm_tx_data_valid,
areset_n => arst_n,
tx_data => mm_tx_data,
tx_busy => tx_busy,
tx_bit => tx);
-- tx_complete => dumb_tx_complete, 
-- tx_enable => dumb_tx_enable,
-- baud_rate_clk => dumb_tx_baud_rate_clk,
-- shift_pulse => dumb_tx_shift_pulse);
-- data_buffer => dumb_tx_data_buffer);

receiver : UART_rx

 port map
 
 (clk => clk,
areset_n => arst_n,
rx_data => rx_data,
rx_err => rx_err,
rx_busy => rx_busy,
rx => rx);


end architecture;
